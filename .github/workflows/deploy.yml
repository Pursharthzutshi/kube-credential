name: Deploy to EKS

on:
  workflow_dispatch:
    inputs:
      aws-region:
        description: AWS region
        required: true
        default: us-east-1
      cluster-name:
        description: EKS cluster name
        required: true
        default: zupple-eks
      node-instance-type:
        description: Node instance type
        required: true
        default: t3.medium

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      # NOTE: for workflow_dispatch inputs in the same workflow use github.event.inputs
      AWS_REGION: ${{ github.event.inputs['aws-region'] }}
      CLUSTER_NAME: ${{ github.event.inputs['cluster-name'] }}
      NODE_INSTANCE_TYPE: ${{ github.event.inputs['node-instance-type'] }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure aws CLI present (safe-check)
        run: |
          if ! command -v aws >/dev/null 2>&1; then
            echo "aws CLI missing â€” installing"
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -sLo /tmp/awscliv2.zip
            unzip -q /tmp/awscliv2.zip -d /tmp
            sudo /tmp/aws/install
          else
            aws --version
          fi

      - name: Install dependencies (kubectl)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq unzip
          # install kubectl for the cluster version (use official stable link or action)
          curl -sSLo /tmp/kubectl https://s3.us-west-2.amazonaws.com/amazon-eks/1.29.0/2024-08-12/bin/linux/amd64/kubectl
          chmod +x /tmp/kubectl && sudo mv /tmp/kubectl /usr/local/bin/kubectl
          kubectl version --client

      - name: Create/Update CloudFormation stack (EKS + ECR)
        env:
          STACK_NAME: ${{ env.CLUSTER_NAME }}-stack
        run: |
          aws cloudformation deploy \
            --template-file infra/eks-stack.yaml \
            --stack-name $STACK_NAME \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              ClusterName=${{ env.CLUSTER_NAME }} \
              KubernetesVersion=1.29 \
              NodeInstanceType=${{ env.NODE_INSTANCE_TYPE }}

      - name: Fetch ECR repo URIs
        id: ecr
        run: |
          STACK_NAME=${{ env.CLUSTER_NAME }}-stack
          FRONTEND=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendEcrUri`].OutputValue' --output text)
          ISSUANCE=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
            --query 'Stacks[0].Outputs[?OutputKey==`IssuanceEcrUri`].OutputValue' --output text)
          VERIFICATION=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
            --query 'Stacks[0].Outputs[?OutputKey==`VerificationEcrUri`].OutputValue' --output text)
          echo "frontend=$FRONTEND" >> $GITHUB_OUTPUT
          echo "issuance=$ISSUANCE" >> $GITHUB_OUTPUT
          echo "verification=$VERIFICATION" >> $GITHUB_OUTPUT
          echo "Found ECR URIs: $FRONTEND $ISSUANCE $VERIFICATION"

      - name: ECR Login
        run: |
          # extract registry host from frontend ECR URI (e.g. 123456789012.dkr.ecr.us-east-1.amazonaws.com)
          REGISTRY_HOST=$(echo "${{ steps.ecr.outputs.frontend }}" | cut -d'/' -f1)
          echo "Logging into ECR registry: $REGISTRY_HOST"
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $REGISTRY_HOST

      - name: Build and push images
        run: |
          FRONTEND_URI=${{ steps.ecr.outputs.frontend }}
          ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
          VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

          echo "Building frontend -> $FRONTEND_URI:latest"
          docker build \
            --build-arg VITE_ISSUANCE_URL=http://issuance-service:4001 \
            --build-arg VITE_VERIFY_URL=http://verification-service:4002 \
            -t $FRONTEND_URI:latest ./frontend
          docker push $FRONTEND_URI:latest

          echo "Building issuance -> $ISSUANCE_URI:latest"
          docker build -t $ISSUANCE_URI:latest ./backend/issuance-service
          docker push $ISSUANCE_URI:latest

          echo "Building verification -> $VERIFICATION_URI:latest"
          docker build -t $VERIFICATION_URI:latest ./backend/verification-service
          docker push $VERIFICATION_URI:latest

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_REGION

      - name: Wait for nodegroup to be ready
        run: |
          for i in {1..30}; do
            READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c 'Ready' || true)
            if [ "$READY_NODES" -ge 1 ]; then
              echo "Nodes are ready ($READY_NODES)"
              break
            fi
            echo "Waiting for nodes... ($i)"
            sleep 20
          done

      - name: Apply Kubernetes manifests (with image substitution)
        run: |
          FRONTEND_URI=${{ steps.ecr.outputs.frontend }}
          ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
          VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

          # replace placeholders in k8s manifests
          sed "s#yourdockerhub/kube-frontend:latest#$FRONTEND_URI:latest#g" k8s/frontend-deployment.yaml > /tmp/frontend.yaml
          sed "s#yourdockerhub/issuance-service:latest#$ISSUANCE_URI:latest#g" k8s/issuance-deployment.yaml > /tmp/issuance.yaml
          sed "s#yourdockerhub/verification-service:latest#$VERIFICATION_URI:latest#g" k8s/verification-deployment.yaml > /tmp/verification.yaml

          # apply DB + service + deployments
          kubectl apply -f k8s/mongo-deployment.yaml
          kubectl apply -f /tmp/issuance.yaml
          kubectl apply -f /tmp/verification.yaml
          kubectl apply -f /tmp/frontend.yaml

      - name: Show services
        run: kubectl get svc -o wide
