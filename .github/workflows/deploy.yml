# name: Deploy to EKS

# on:
#   workflow_dispatch:
#     inputs:
#       aws-region:
#         description: AWS region
#         required: true
#         default: us-east-1
#       cluster-name:
#         description: EKS cluster name
#         required: true
#         default: zupple-eks
#       node-instance-type:
#         description: Node instance type
#         required: true
#         default: t3.medium
#       deploy-frontend:
#         description: Deploy frontend component
#         required: true
#         default: 'false'
#         type: choice
#         options: ['true','false']
#       deploy-issuance:
#         description: Deploy issuance backend
#         required: true
#         default: 'true'
#         type: choice
#         options: ['true','false']
#       deploy-verification:
#         description: Deploy verification backend
#         required: true
#         default: 'true'
#         type: choice
#         options: ['true','false']

# jobs:
#   deploy:
#     runs-on: ubuntu-latest
#     permissions:
#       id-token: write
#       contents: read
#     env:
#       AWS_REGION: ${{ github.event.inputs.aws-region }}
#       CLUSTER_NAME: ${{ github.event.inputs.cluster-name }}
#       DEPLOY_FRONTEND: ${{ github.event.inputs.deploy-frontend }}
#       DEPLOY_ISSUANCE: ${{ github.event.inputs.deploy-issuance }}
#       DEPLOY_VERIFICATION: ${{ github.event.inputs.deploy-verification }}
#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Install dependencies
#         run: |
#           sudo apt-get update -y
#           sudo apt-get install -y jq
#           curl -sSLo kubectl https://s3.us-west-2.amazonaws.com/amazon-eks/1.29.0/2024-08-12/bin/linux/amd64/kubectl
#           chmod +x kubectl && sudo mv kubectl /usr/local/bin/
#           curl -sSLo aws-iam-authenticator https://github.com/kubernetes-sigs/aws-iam-authenticator/releases/download/v0.6.22/aws-iam-authenticator_0.6.22_linux_amd64
#           chmod +x aws-iam-authenticator && sudo mv aws-iam-authenticator /usr/local/bin/

#       - name: Create/Update CloudFormation stack (EKS + ECR)
#         run: |
#           STACK_NAME=${CLUSTER_NAME}-stack
          
#           # Test if we have basic CloudFormation permissions
#           if aws cloudformation describe-stacks --stack-name $STACK_NAME >/dev/null 2>&1; then
#             echo "Stack $STACK_NAME exists, updating..."
#             aws cloudformation deploy \
#               --template-file infra/eks-stack.yaml \
#               --stack-name $STACK_NAME \
#               --capabilities CAPABILITY_NAMED_IAM \
#               --parameter-overrides \
#                 ClusterName=${CLUSTER_NAME} \
#                 KubernetesVersion=1.29 \
#                 NodeInstanceType=${{ github.event.inputs.node-instance-type }}
#           elif aws cloudformation validate-template --template-body file://infra/eks-stack.yaml >/dev/null 2>&1; then
#             echo "Stack $STACK_NAME does not exist. Attempting to create..."
#             aws cloudformation deploy \
#               --template-file infra/eks-stack.yaml \
#               --stack-name $STACK_NAME \
#               --capabilities CAPABILITY_NAMED_IAM \
#               --parameter-overrides \
#                 ClusterName=${CLUSTER_NAME} \
#                 KubernetesVersion=1.29 \
#                 NodeInstanceType=${{ github.event.inputs.node-instance-type }}
#           else
#             echo "CloudFormation permissions insufficient. Creating ECR repositories directly..."
#             # Create ECR repositories directly without CloudFormation
#             aws ecr create-repository --repository-name ${CLUSTER_NAME}-frontend --region $AWS_REGION 2>/dev/null || echo "Frontend repo already exists"
#             aws ecr create-repository --repository-name ${CLUSTER_NAME}-issuance --region $AWS_REGION 2>/dev/null || echo "Issuance repo already exists"
#             aws ecr create-repository --repository-name ${CLUSTER_NAME}-verification --region $AWS_REGION 2>/dev/null || echo "Verification repo already exists"
#             echo "ECR repositories created. EKS cluster must be created manually or with proper CloudFormation permissions."
#           fi

#       - name: Fetch ECR repo URIs
#         id: ecr
#         run: |
#           STACK_NAME=${CLUSTER_NAME}-stack
          
#           # Check if we have CloudFormation describe permissions
#           if aws cloudformation describe-stacks --stack-name $STACK_NAME >/dev/null 2>&1; then
#             echo "Using CloudFormation to get ECR URIs"
#             FRONTEND=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
#               --query 'Stacks[0].Outputs[?OutputKey==`FrontendEcrUri`].OutputValue' --output text)
#             ISSUANCE=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
#               --query 'Stacks[0].Outputs[?OutputKey==`IssuanceEcrUri`].OutputValue' --output text)
#             VERIFICATION=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
#               --query 'Stacks[0].Outputs[?OutputKey==`VerificationEcrUri`].OutputValue' --output text)
#           else
#             echo "CloudFormation describe permission denied. Using ECR list-repositories as fallback"
#             # Fallback: construct ECR URIs using standard naming convention
#             AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
#             FRONTEND="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${CLUSTER_NAME}-frontend"
#             ISSUANCE="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${CLUSTER_NAME}-issuance"
#             VERIFICATION="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${CLUSTER_NAME}-verification"
#           fi
          
#           echo "frontend=$FRONTEND" >> $GITHUB_OUTPUT
#           echo "issuance=$ISSUANCE" >> $GITHUB_OUTPUT
#           echo "verification=$VERIFICATION" >> $GITHUB_OUTPUT

#       - name: Ensure ECR repositories exist
#         run: |
#           set -euo pipefail

#           echo "AWS region: $AWS_REGION"
#           AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
#           echo "AWS account: $AWS_ACCOUNT_ID"

#           FRONTEND_URI=${{ steps.ecr.outputs.frontend }}
#           ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
#           VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

#           REPO_URIS=()
#           if [ "$DEPLOY_FRONTEND" = "true" ]; then REPO_URIS+=("$FRONTEND_URI"); fi
#           if [ "$DEPLOY_ISSUANCE" = "true" ]; then REPO_URIS+=("$ISSUANCE_URI"); fi
#           if [ "$DEPLOY_VERIFICATION" = "true" ]; then REPO_URIS+=("$VERIFICATION_URI"); fi

#           for REPO_URI in "${REPO_URIS[@]}"; do
#             REPO_NAME=$(echo "$REPO_URI" | cut -d'/' -f2)

#             if ! aws ecr describe-repositories --repository-names "$REPO_NAME" --region $AWS_REGION >/dev/null 2>&1; then
#               echo "Creating ECR repository: $REPO_NAME"
#               if ! aws ecr create-repository --repository-name "$REPO_NAME" --region $AWS_REGION >/dev/null 2>&1; then
#                 echo "ERROR: Failed to create ECR repository '$REPO_NAME' in $AWS_REGION for account $AWS_ACCOUNT_ID"
#                 echo "Please ensure this identity has ecr:CreateRepository and ecr:DescribeRepositories permissions."
#                 aws sts get-caller-identity || true
#                 exit 1
#               fi
#               # Wait until the repo is visible to avoid eventual consistency issues
#               for i in {1..10}; do
#                 if aws ecr describe-repositories --repository-names "$REPO_NAME" --region $AWS_REGION >/dev/null 2>&1; then
#                   echo "Confirmed ECR repository available: $REPO_NAME"
#                   break
#                 fi
#                 echo "Waiting for ECR repository to become available: $REPO_NAME ($i)"
#                 sleep 3
#               done
#             else
#               echo "ECR repository exists: $REPO_NAME"
#             fi
#           done

#       - name: ECR Login
#         run: aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $(echo "${{ steps.ecr.outputs.frontend }}" | cut -d'/' -f1)

#       - name: Preflight ECR check (debug)
#         run: |
#           set -euo pipefail
#           echo "AWS region: $AWS_REGION"
#           AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
#           echo "AWS account: $AWS_ACCOUNT_ID"

#           FRONTEND_URI=${{ steps.ecr.outputs.frontend }}
#           ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
#           VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

#           echo "Resolved URIs (considering toggles):"
#           if [ "$DEPLOY_FRONTEND" = "true" ]; then echo "  FRONTEND_URI=$FRONTEND_URI"; else echo "  FRONTEND skipped"; fi
#           if [ "$DEPLOY_ISSUANCE" = "true" ]; then echo "  ISSUANCE_URI=$ISSUANCE_URI"; else echo "  ISSUANCE skipped"; fi
#           if [ "$DEPLOY_VERIFICATION" = "true" ]; then echo "  VERIFICATION_URI=$VERIFICATION_URI"; else echo "  VERIFICATION skipped"; fi

#           echo "Listing ECR repositories in $AWS_REGION..."
#           aws ecr describe-repositories --region $AWS_REGION --query 'repositories[].repositoryName' --output text || true

#           REPO_URIS=()
#           if [ "$DEPLOY_FRONTEND" = "true" ]; then REPO_URIS+=("$FRONTEND_URI"); fi
#           if [ "$DEPLOY_ISSUANCE" = "true" ]; then REPO_URIS+=("$ISSUANCE_URI"); fi
#           if [ "$DEPLOY_VERIFICATION" = "true" ]; then REPO_URIS+=("$VERIFICATION_URI"); fi

#           for REPO_URI in "${REPO_URIS[@]}"; do
#             REPO_NAME=$(echo "$REPO_URI" | cut -d'/' -f2)
#             if aws ecr describe-repositories --repository-names "$REPO_NAME" --region $AWS_REGION >/dev/null 2>&1; then
#               echo "OK: Found repository $REPO_NAME"
#             else
#               echo "ERROR: Missing repository $REPO_NAME in $AWS_REGION for account $AWS_ACCOUNT_ID"
#               exit 1
#             fi
#           done

#       - name: Build and push images
#         run: |
#           FRONTEND_URI=${{ steps.ecr.outputs.frontend }}
#           ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
#           VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

#           if [ "$DEPLOY_FRONTEND" = "true" ]; then
#             docker build \
#               --build-arg VITE_ISSUANCE_URL=http://issuance-service:4001 \
#               --build-arg VITE_VERIFY_URL=http://verification-service:4002 \
#               -t $FRONTEND_URI:latest ./frontend
#             docker push $FRONTEND_URI:latest
#           else
#             echo "Skipping frontend build/push"
#           fi

#           if [ "$DEPLOY_ISSUANCE" = "true" ]; then
#             docker build -t $ISSUANCE_URI:latest ./backend/issuance-service
#             docker push $ISSUANCE_URI:latest
#           else
#             echo "Skipping issuance-service build/push"
#           fi

#           if [ "$DEPLOY_VERIFICATION" = "true" ]; then
#             docker build -t $VERIFICATION_URI:latest ./backend/verification-service
#             docker push $VERIFICATION_URI:latest
#           else
#             echo "Skipping verification-service build/push"
#           fi

#       - name: Update kubeconfig
#         run: |
#           # Check if EKS cluster exists
#           if aws eks describe-cluster --name $CLUSTER_NAME --region $AWS_REGION >/dev/null 2>&1; then
#             echo "EKS cluster $CLUSTER_NAME exists, updating kubeconfig..."
#             aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_REGION
#           else
#             echo "ERROR: EKS cluster $CLUSTER_NAME does not exist!"
#             echo "Please create the EKS cluster manually or request CloudFormation permissions."
#             echo ""
#             echo "To create manually:"
#             echo "eksctl create cluster --name $CLUSTER_NAME --region $AWS_REGION --node-type ${{ github.event.inputs.node-instance-type }} --nodes 2"
#             exit 1
#           fi

#       - name: Wait for nodegroup to be ready
#         run: |
#           for i in {1..30}; do
#             READY_NODES=$(kubectl get nodes --no-headers | grep -c ' Ready ' || true)
#             if [ "$READY_NODES" -ge 1 ]; then
#               echo "Nodes are ready"
#               break
#             fi
#             echo "Waiting for nodes... ($i)"
#             sleep 20
#           done

#       - name: Apply Kubernetes manifests (with image substitution)
#         run: |
#           FRONTEND_URI=${{ steps.ecr.outputs.frontend }}
#           ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
#           VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

#           if [ "$DEPLOY_FRONTEND" = "true" ]; then
#             sed "s#yourdockerhub/kube-frontend:latest#$FRONTEND_URI:latest#g" k8s/frontend-deployment.yaml > /tmp/frontend.yaml
#           fi
#           if [ "$DEPLOY_ISSUANCE" = "true" ]; then
#             sed "s#yourdockerhub/issuance-service:latest#$ISSUANCE_URI:latest#g" k8s/issuance-deployment.yaml > /tmp/issuance.yaml
#           fi
#           if [ "$DEPLOY_VERIFICATION" = "true" ]; then
#             sed "s#yourdockerhub/verification-service:latest#$VERIFICATION_URI:latest#g" k8s/verification-deployment.yaml > /tmp/verification.yaml
#           fi

#           kubectl apply -f k8s/mongo-deployment.yaml
#           if [ "$DEPLOY_ISSUANCE" = "true" ]; then kubectl apply -f /tmp/issuance.yaml; else echo "Skipping issuance k8s apply"; fi
#           if [ "$DEPLOY_VERIFICATION" = "true" ]; then kubectl apply -f /tmp/verification.yaml; else echo "Skipping verification k8s apply"; fi
#           if [ "$DEPLOY_FRONTEND" = "true" ]; then kubectl apply -f /tmp/frontend.yaml; else echo "Skipping frontend k8s apply"; fi

#       - name: Show services
#         run: kubectl get svc -o wide


name: Deploy to EKS

on:
  workflow_dispatch:
    inputs:
      aws-region:
        description: AWS region
        required: true
        default: us-east-1
      cluster-name:
        description: EKS cluster name
        required: true
        default: zupple-eks
      node-instance-type:
        description: Node instance type
        required: true
        default: t3.medium
      deploy-issuance:
        description: Deploy issuance backend
        required: true
        default: 'true'
        type: choice
        options: ['true','false']
      deploy-verification:
        description: Deploy verification backend
        required: true
        default: 'true'
        type: choice
        options: ['true','false']

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: ${{ github.event.inputs.aws-region }}
      CLUSTER_NAME: ${{ github.event.inputs.cluster-name }}
      DEPLOY_ISSUANCE: ${{ github.event.inputs.deploy-issuance }}
      DEPLOY_VERIFICATION: ${{ github.event.inputs.deploy-verification }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq
          curl -sSLo kubectl https://s3.us-west-2.amazonaws.com/amazon-eks/1.29.0/2024-08-12/bin/linux/amd64/kubectl
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          curl -sSLo aws-iam-authenticator https://github.com/kubernetes-sigs/aws-iam-authenticator/releases/download/v0.6.22/aws-iam-authenticator_0.6.22_linux_amd64
          chmod +x aws-iam-authenticator && sudo mv aws-iam-authenticator /usr/local/bin/

      - name: Create/Update CloudFormation stack (EKS + ECR)
        run: |
          STACK_NAME=${CLUSTER_NAME}-stack

          # If describe-stacks works, use CloudFormation deploy
          if aws cloudformation describe-stacks --stack-name $STACK_NAME >/dev/null 2>&1; then
            echo "Stack $STACK_NAME exists, updating..."
            aws cloudformation deploy \
              --template-file infra/eks-stack.yaml \
              --stack-name $STACK_NAME \
              --capabilities CAPABILITY_NAMED_IAM \
              --parameter-overrides \
                ClusterName=${CLUSTER_NAME} \
                KubernetesVersion=1.29 \
                NodeInstanceType=${{ github.event.inputs.node-instance-type }}
          elif aws cloudformation validate-template --template-body file://infra/eks-stack.yaml >/dev/null 2>&1; then
            echo "Stack $STACK_NAME does not exist. Attempting to create..."
            aws cloudformation deploy \
              --template-file infra/eks-stack.yaml \
              --stack-name $STACK_NAME \
              --capabilities CAPABILITY_NAMED_IAM \
              --parameter-overrides \
                ClusterName=${CLUSTER_NAME} \
                KubernetesVersion=1.29 \
                NodeInstanceType=${{ github.event.inputs.node-instance-type }}
          else
            echo "CloudFormation permissions insufficient. Creating ECR repositories directly..."
            aws ecr create-repository --repository-name ${CLUSTER_NAME}-issuance --region $AWS_REGION 2>/dev/null || echo "Issuance repo already exists"
            aws ecr create-repository --repository-name ${CLUSTER_NAME}-verification --region $AWS_REGION 2>/dev/null || echo "Verification repo already exists"
            echo "ECR repositories created (or already exist). EKS cluster must be created manually or with proper CloudFormation permissions."
          fi

      - name: Fetch ECR repo URIs
        id: ecr
        run: |
          STACK_NAME=${CLUSTER_NAME}-stack

          if aws cloudformation describe-stacks --stack-name $STACK_NAME >/dev/null 2>&1; then
            echo "Using CloudFormation to get ECR URIs"
            ISSUANCE=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
              --query 'Stacks[0].Outputs[?OutputKey==`IssuanceEcrUri`].OutputValue' --output text)
            VERIFICATION=$(aws cloudformation describe-stacks --stack-name $STACK_NAME \
              --query 'Stacks[0].Outputs[?OutputKey==`VerificationEcrUri`].OutputValue' --output text)
          else
            echo "CloudFormation describe permission denied. Using ECR list-repositories as fallback"
            AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            ISSUANCE="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${CLUSTER_NAME}-issuance"
            VERIFICATION="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${CLUSTER_NAME}-verification"
          fi

          echo "issuance=$ISSUANCE" >> $GITHUB_OUTPUT
          echo "verification=$VERIFICATION" >> $GITHUB_OUTPUT

      - name: Ensure ECR repositories exist
        run: |
          set -euo pipefail

          echo "AWS region: $AWS_REGION"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "AWS account: $AWS_ACCOUNT_ID"

          ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
          VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

          REPO_URIS=()
          if [ "$DEPLOY_ISSUANCE" = "true" ]; then REPO_URIS+=("$ISSUANCE_URI"); fi
          if [ "$DEPLOY_VERIFICATION" = "true" ]; then REPO_URIS+=("$VERIFICATION_URI"); fi

          for REPO_URI in "${REPO_URIS[@]}"; do
            REPO_NAME=$(echo "$REPO_URI" | cut -d'/' -f2)

            if ! aws ecr describe-repositories --repository-names "$REPO_NAME" --region $AWS_REGION >/dev/null 2>&1; then
              echo "Creating ECR repository: $REPO_NAME"
              if ! aws ecr create-repository --repository-name "$REPO_NAME" --region $AWS_REGION >/dev/null 2>&1; then
                echo "ERROR: Failed to create ECR repository '$REPO_NAME' in $AWS_REGION for account $AWS_ACCOUNT_ID"
                echo "Please ensure this identity has ecr:CreateRepository and ecr:DescribeRepositories permissions."
                aws sts get-caller-identity || true
                exit 1
              fi
              # Wait until the repo is visible to avoid eventual consistency issues
              for i in {1..10}; do
                if aws ecr describe-repositories --repository-names "$REPO_NAME" --region $AWS_REGION >/dev/null 2>&1; then
                  echo "Confirmed ECR repository available: $REPO_NAME"
                  break
                fi
                echo "Waiting for ECR repository to become available: $REPO_NAME ($i)"
                sleep 3
              done
            else
              echo "ECR repository exists: $REPO_NAME"
            fi
          done

      - name: ECR Login (safe)
        run: |
          # Choose a repo host to login to based on which services are being deployed
          HOST=""
          if [ "${{ env.DEPLOY_ISSUANCE }}" = "true" ] && [ "${{ steps.ecr.outputs.issuance }}" != "" ]; then
            HOST=$(echo "${{ steps.ecr.outputs.issuance }}" | cut -d'/' -f1)
          elif [ "${{ env.DEPLOY_VERIFICATION }}" = "true" ] && [ "${{ steps.ecr.outputs.verification }}" != "" ]; then
            HOST=$(echo "${{ steps.ecr.outputs.verification }}" | cut -d'/' -f1)
          fi

          if [ -z "$HOST" ]; then
            echo "No ECR host determined; skipping docker login (nothing to push)."
          else
            echo "Logging in to ECR host: $HOST"
            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin "$HOST"
          fi

      - name: Preflight ECR check (debug)
        run: |
          set -euo pipefail
          echo "AWS region: $AWS_REGION"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "AWS account: $AWS_ACCOUNT_ID"

          ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
          VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

          echo "Resolved URIs (considering toggles):"
          if [ "$DEPLOY_ISSUANCE" = "true" ]; then echo "  ISSUANCE_URI=$ISSUANCE_URI"; else echo "  ISSUANCE skipped"; fi
          if [ "$DEPLOY_VERIFICATION" = "true" ]; then echo "  VERIFICATION_URI=$VERIFICATION_URI"; else echo "  VERIFICATION skipped"; fi

          echo "Listing ECR repositories in $AWS_REGION..."
          aws ecr describe-repositories --region $AWS_REGION --query 'repositories[].repositoryName' --output text || true

          REPO_URIS=()
          if [ "$DEPLOY_ISSUANCE" = "true" ]; then REPO_URIS+=("$ISSUANCE_URI"); fi
          if [ "$DEPLOY_VERIFICATION" = "true" ]; then REPO_URIS+=("$VERIFICATION_URI"); fi

          for REPO_URI in "${REPO_URIS[@]}"; do
            REPO_NAME=$(echo "$REPO_URI" | cut -d'/' -f2)
            if aws ecr describe-repositories --repository-names "$REPO_NAME" --region $AWS_REGION >/dev/null 2>&1; then
              echo "OK: Found repository $REPO_NAME"
            else
              echo "ERROR: Missing repository $REPO_NAME in $AWS_REGION for account $AWS_ACCOUNT_ID"
              exit 1
            fi
          done

      - name: Build and push images (backends only)
        run: |
          ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
          VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

          if [ "$DEPLOY_ISSUANCE" = "true" ]; then
            echo "Building and pushing issuance image: $ISSUANCE_URI:latest"
            docker build -t $ISSUANCE_URI:latest ./backend/issuance-service
            docker push $ISSUANCE_URI:latest
          else
            echo "Skipping issuance-service build/push"
          fi

          if [ "$DEPLOY_VERIFICATION" = "true" ]; then
            echo "Building and pushing verification image: $VERIFICATION_URI:latest"
            docker build -t $VERIFICATION_URI:latest ./backend/verification-service
            docker push $VERIFICATION_URI:latest
          else
            echo "Skipping verification-service build/push"
          fi

      - name: Update kubeconfig
        run: |
          if aws eks describe-cluster --name $CLUSTER_NAME --region $AWS_REGION >/dev/null 2>&1; then
            echo "EKS cluster $CLUSTER_NAME exists, updating kubeconfig..."
            aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_REGION
          else
            echo "ERROR: EKS cluster $CLUSTER_NAME does not exist!"
            echo "Please create the EKS cluster manually or request CloudFormation permissions."
            echo ""
            echo "To create manually (example):"
            echo "eksctl create cluster --name $CLUSTER_NAME --region $AWS_REGION --node-type ${{ github.event.inputs.node-instance-type }} --nodes 2"
            exit 1
          fi

      - name: Wait for nodegroup to be ready
        run: |
          for i in {1..30}; do
            READY_NODES=$(kubectl get nodes --no-headers | grep -c ' Ready ' || true)
            if [ "$READY_NODES" -ge 1 ]; then
              echo "Nodes are ready"
              break
            fi
            echo "Waiting for nodes... ($i)"
            sleep 20
          done

      - name: Apply Kubernetes manifests (with image substitution)
        run: |
          ISSUANCE_URI=${{ steps.ecr.outputs.issuance }}
          VERIFICATION_URI=${{ steps.ecr.outputs.verification }}

          if [ "$DEPLOY_ISSUANCE" = "true" ]; then
            sed "s#yourdockerhub/issuance-service:latest#$ISSUANCE_URI:latest#g" k8s/issuance-deployment.yaml > /tmp/issuance.yaml
          fi
          if [ "$DEPLOY_VERIFICATION" = "true" ]; then
            sed "s#yourdockerhub/verification-service:latest#$VERIFICATION_URI:latest#g" k8s/verification-deployment.yaml > /tmp/verification.yaml
          fi

          # Apply shared infra (e.g., mongo)
          kubectl apply -f k8s/mongo-deployment.yaml

          if [ "$DEPLOY_ISSUANCE" = "true" ]; then kubectl apply -f /tmp/issuance.yaml; else echo "Skipping issuance k8s apply"; fi
          if [ "$DEPLOY_VERIFICATION" = "true" ]; then kubectl apply -f /tmp/verification.yaml; else echo "Skipping verification k8s apply"; fi

      - name: Show services
        run: kubectl get svc -o wide
